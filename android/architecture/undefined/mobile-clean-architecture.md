# Mobile Clean Architecture

클린 아키텍처에 대해서 알아보기 전에 ‘로버트 C. 마틴’의 클린 아키텍처 중에서 중요한 문장을 보고 들어가보자.

> 소프트웨어 아키텍처는 선을 긋는 기술이며, 나는 이러한 선을 \*\*경계(boundary)\*\*라고 부른다. 경계는 소프트웨어 요소를 서로 분리하고, 경계 한편에 있는 요소가 반대편에 있는 요소를 알지 못하도록 막는다. - _로버트 C. 마틴, 클린 아키텍처 중에서_

### 경계선의 구분

<mark style="color:orange;">**단일 책임 원칙(SRP)**</mark>

* 모바일 앱의 가장 큰 액터: 이용자, 비즈니스 로직 실행자 …
* 액터의 세분화를 통해서 책임을 쪼갤 수 있음
  * ex) 이용자 → 회원가입을 원하는 이용자, 검색하는 이용자 …

### 공통 폐쇄 원칙(Common Closure Principle)

<mark style="color:orange;">**CCP = SRP(단일 책임 원칙) + OCP(개방-폐쇄 원칙)**</mark>

* 각 계층은 하나의 (큰) 액터만을 가짐
* 가장 높은 수준의 계층은 그보다 하위의 계층의 변화로부터 보호되어야 함

### 도메인 계층(유스케이스)의 지위

<mark style="color:orange;">**가장 높은 수준의 계층**</mark>

* 비즈니스적으로 가지고 있는 특정 앱의 니즈를 담당
  * ex) 회원가입, 리뷰, 사용자가 어떤 항목을 누르면 장바구니에 담겨야 함 …



### 일반적인 클린 아키텍처 구조

![](<../../../.gitbook/assets/Untitled (10) (2).png>)

여기서 말하는 엔티티는 일반적인 데이터의 엔티티가 아닌, 업무 규칙을 정의하는 곳이다. 앱 안에서 사용하는 비즈니스 규칙을 어떤 의미를 정의하는 곳이 유스케이스라고 보면 된다(기술적인 단어 x 일반적인 단어 o). 유스케이스에 서비스를 제공하는 것이 프레젠터고, 그 프레젠터를 통해서 UI와 상호작용 한다.

**가장 안으로 갈 수록 높은 계층이고, 바깥으로 갈 수록 낮은 계층**이다. 높은 계층으로 갈 수록 외부로부터 보호되는데 유스케이스의 경우 가장 바깥 쪽의 위치한 UI와 직접 상호작용 할 수 없다.

이런 바탕을 배경으로 어떻게 모바일에 적용하면 좋을지에 대해서 알아보자.



### 모바일 클린 아키텍처 구조

![](<../../../.gitbook/assets/Untitled (11).png>)

#### <mark style="color:green;">**UI(Presentation) Layer**</mark>

**화면에 표시, 애니메이션, 사용자 입력 처리 등 UI에 관련된 모든 처리를 담당**한다. UI Layer 내부에서도 명확한 컴포넌트의 분리는 필수이다(SRP).

<mark style="color:green;">**View**</mark>

위의 클린 아키텍처 그림에서 볼 수 있듯이 View는 가장 하위 레벨이다.

View의 역할은 **사용자(User)와 직접적인 소통을 담당**한다. 예를 들면, 사용자의 입력이나 화면 클릭과 같은 것들이다.

또한, **직접적으로 플랫폼에 의존적인 구현을 담당**한다. 즉, UI 화면 표시와 사용자 입력만 담당한다. 여기서 말하는 플랫폼 의존적이란 **android의 context**라고 생각하면 된다(시스템 접근 등과 같은 로직을 처리). context 의존성을 가짐으로써 반대로 생각하면 context 없이는 View 클래스의 동작은 불가하다. 이런 **의존성을 가지는 모든 로직들을 View에 집중 시킴으로써** Presenter나 ViewModel이 접근하지 않도록 한다.

여기서 주의할 점은 View가 꼭 Activity나 Fragment를 의미하지는 않는다.

<mark style="color:green;">**Presenter(Presenter or ViewModel)**</mark>

**사용자에게 제공할 UI를 위한 비즈니스 로직을 담당**한다. 예를 들면, 사용자의 입력을 받아 특정 유스케이스를 호출하는 로직을 담당한다.

뷰와는 달리 **OS의 렌더링 API 등에 직접적으로 의존하지 않는다**. 그러므로 플랫폼에 직접적으로 의존해서는 안된다. Presenter에서 제공하는 모든 메서드들은 플랫폼에 직접적으로 의존하지 않기 때문에 JVM 위에서도 단위 테스트가 가능해야 한다.

사용자 입력(이벤트)가 왔을 때 어떤 판단(로직)을 처리해야 하는지에 대해서도 Presenter가 처리한다.

#### <mark style="color:blue;">Domain Layer</mark>

<mark style="color:blue;">**UseCase**</mark>

유스케이스는 도메인 관점의 비즈니스 로직을 담당한다. 알고 넘어가야 할 점은 여러 가지 방면으로 구현이 가능하다는 것이다.

💡 _UI 관점의 비즈니스 로직과 도메인 관점의 비즈니스 로직의 차이점은 무엇일까?_

⇒ 도메인 관점의 비즈니스 로직은 **도메인 지식을 가지고 있는 사람들의 관점에 대한 비즈니스 로직**을 뜻한다. 다시 말해 개발자가 아닌 사람, 개발에 대한 깊은 지식은 없지만 유저에 대한 자식이 있는 기획자도 포함될 수 있다(ex: B2B, QA …). **이러한 사람들이 알아야 하는** **업무 규칙을 정의하는 곳이 도메인 관점의 비즈니스 로직**이다.

<mark style="color:blue;">**Model**</mark>

앱의 논리적인 엔티티 데이터를 관리한다. 즉, **도메인 계층에서 사용될 데이터를 관리**한다고 생각하면 된다.

<mark style="color:blue;">**Translater**</mark>

데이터 계층의 엔티티를 뜻하고, **도메인 모델을 변환하는 Mapper 역할**을 한다.

데이터 계층에서 받아온 Low-Level(Local DB Data, Remote Data) 한 데이터들은 실제 앱에서 사용될 데이터와 관점이 다르다. 앱에서 사용할 데이터 구조를 맞춰주기 위해 변환해주는 역할을 한다.

💡 도메인 계층에 대한 비즈니스 로직이 거의 없을때도 굳이 도메인 모듈을 만들어야 할까??

⇒ 앱에서 도메인 계층의 비즈니스 로직이 거의 없을때는 굳이 유스케이스, 도메인의 이름을 가진 모듈을 만들 필요는 없다. 예를 들어, 유스케이스가 앱 데이터와 서버 데이터의 중재자 역할만 할 때나, 도메인 지식과 거리가 먼 다른 서비스에 대한 로직이 있을 때는 다른 이름의 모듈을 생성해주거나 생략해도 된다.

이런 관점에서 봤을 때, 도메인 계층은 Optional 하다고 볼 수 있다. 특히 많은 앱들에서는 가장 중요한 도메인 로직들은 서버가 담당하고 있기 때문이다.

#### <mark style="color:purple;">Data Layer</mark>

<mark style="color:purple;">**Repository(Interface)**</mark>

Repository는 데이터 계층의 인터페이스이다. **데이터 계층에서 도메인 계층 또는 UI 계층에서 내부의 데이터 처리들을 완전히 감춰주는 중요한 역할**을 한다.

이러한 감춰진 내부 데이터 처리 같은 경우, 유스케이스가 필요로 하는 데이터 저장/수정 등의 기능을 제공한다.

또한, 데이터소스를 인터페이스 형태로 참조하기 때문에 Repository 클래스에서 데이터소스 객체를 갈아끼우는 형태로 외부 API 호출(Remote), 로컬 DB 접근, mock object 출력을 전환할 수 있다.

💡 일반적으로 Mobile 포지션에서 생각하기에 Repository는 Remote Server 또는 Local DB에 요청 및 응답을 위해서 필요로 한게 아닌가? 왜 저장소라고 말할까?

⇒ **데이터를 쓰고 읽고 편집하는 것에 대한 추상화라는 개념**에서 생각하면 이해가 될 것이다. Repository는 내부의 데이터 처리를 감춰주는 역할을 한다고 앞서 언급했다. 즉, OCP에서 언급했듯이 추상화를 통해 사용자에게 필요한 것만 노출함으로써 폐쇄 원칙을 만족하고, 구현 클래스의 내용을 감춰야 한다.

<mark style="color:purple;">**DataSource**</mark>

데이터소스의 주된 역할은 **외부 모듈로부터 감추어 주어야한다**. 즉, **실제 데이터의 입출력을 추상화** 시킴에 의의를 둬야한다.

동일한 입출력을 위한 Low-Level을 담당하는 인터페이스(DataSource)가 있고, 그 하부에 사용될 방법에 따라 Local, Fake, Remote 구현체 클래스가 생겨날텐데 이러한 내부 구현의 복잡성, 로직 처리 과정을 감춰줄 수 있는 중요한 역할을 한다.

💡 데이터소스를 왜 굳이 인터페이스로 만들어야 할까?

⇒ 일반적으로 DB 교체(Room → SqlLite)가 일어날 때를 위해 인터페이스를 두어야 한다고 생각할 수 있다. 하지만 실제로 DB 교체는 거의 일어나지 않는데, 이러한 일어날 수도 있는 것을 예방하는 목적으로 사용해야 할까? 굳이 그렇게 생각하지 말고 **추상화의 관점에서 생각**하자. **데이터가 실제로 사용되는 메커니즘에 대해서 더 상위 레벨에 있는 곳에서 알 필요도 없고, 알 수도 없게 감춘다는 것**에 대해서 포커스하자.

<mark style="color:purple;">**Entity**</mark>

엔티티는 데이터 소스에서 사용되는 데이터를 정의한 모델이다(앞서 그림의 엔티티와는 다른 개념)

REST API의 요청 및 응답을 위한 JSON, Local DB에 저장된 테이블을 표현하는 data class 형태가 일반적이다.



