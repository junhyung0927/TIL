# MVx의 대원칙

## UI 계층(MVx)의 대원칙

**어떤 경우이든 Model은 분리되어야 한다**

* 적어도 데이터 계층(로컬 DB 사용, Remote API 접근 등)에서 처리되는 모든 로직은 UI 레이어에서 독립

**뷰의 역할을 할 수 있는 한 분리시켜야 한다는 공통의 문제 의식**

**Android에서 발생할 수 있는 특수한 상황들을 잘 처리할 수 있는 체계가 필요**

* Context 처리(Activity Context, Device Context, Application Context …)
* 생명 주기 이벤트(Lifecycle Event) 처리 : 앱의 안정성을 보장할 필요가 있고, 이벤트 처리 과정에서 사용자에게 기대하지 않은 동작을 보여줘서는 안됨
* 할 수 있는 한 많은 부분이 테스트 가능하도록 만들어져야 함

### MVC 패턴

<figure><img src="../../../.gitbook/assets/Untitled (34).png" alt=""><figcaption></figcaption></figure>

모델 (Data + Domain) 계층에서는 비즈니스 로직을 뷰에서는 UI 로직을 제공한다. 컨트롤러(Controller)는 어떤 뷰를 보여줄 것인가를 결정해서, 모델에서 받은 데이터를 뷰로 넘겨준다. 또한, 에러를 어떻게 보여줄지를 결정해서 뷰로 넘겨준다.

플랫폼을 막론하고 유용하게 적용되는 패러다임이다.

* 특히 웹 환경에서 잘 동작한다. 뷰와 모델이 각자의 잘 분화된 클래스들을 제공하고, 컨트롤러가 이들을 잘 조직화 할 수 있다.

### 왜 안드로이드에서 MVC는 잘 동작하지 않는가?

안드로이드에서 자주 쓰이는 MVVM 패턴을 사용하기 전에 기존의 MVC의 단점을 파악하고 이를 보완하고자 다른 패턴들이 생겼다는 것을 아는 것이 중요하다. 맹목적으로 평판이 좋은 패턴을 사용하기 보단 근본적으로 어떤 문제점이 발생해 어떻게 해결 했는지를 알아야 한다.

#### 모바일 환경의 문제

* 복잡한 비동기 처리
* 라이프 사이클 처리
* UI 로직 분리의 어려움
  * 웹의 html에서는 뷰가 컨트롤러와 완전히 독립된 형태로 UI 로직을 구현할 수 있지만, 모바일은 그렇지 못하다

#### 안드로이드의 문제 : 뷰 - 컨트롤러 분리의 애매함

* 뷰 : 안드로이드의 XML은 기본 레이아웃만을 제공한다. UI 로직이 들어갈 여지가 없다(리스트 구현 시 특히 이런 문제점이 발생 ⇒ 리사이클러뷰, 어댑터 …)
* 컨트롤러 : 액티비티 / 프래그먼트가 컨트롤러의 역할을 하는 것이 불가피하다. 결국 액티비티 / 프래그먼트가 뷰, 컨트롤러 모두를 담당하는 문제점이 발생한다.

#### 그 결과 - 총체적 난국 : 가독성, 유지보수성, 확장성 떨어짐

* Fat Activity : Activity - Fragment에 너무 많은 로직이 들어간다
* 유닛 테스트를 만들기가 매우 까다롭다. 대부분의 테스트 케이스에서 context가 필요하게 된다.

### MVC 해결책

#### 뷰의 분화

<figure><img src="../../../.gitbook/assets/Untitled (35) (1).png" alt=""><figcaption></figcaption></figure>

안드로이드는 \<include> 태그를 통해 XML 정의를 여러 개로 분리 가능하다.

나눈 View들은 Activity / Fragment가 아닌 별도의 컨트롤러를 통해 제어가 가능하다. 이를 통해 상당한 복잡도를 낮출 수 있다.

#### ViewController

<figure><img src="../../../.gitbook/assets/Untitled (36).png" alt=""><figcaption></figcaption></figure>

Activity / Fragment는 뷰도 컨트롤러도 아니도록 역할을 주어야 한다.

⇒ 화면 안 요소들의 생성, 라이프 사이클 처리, context에 밀접한 처리를 bridge 해주는 역할만 남겨야 한다.

각 뷰마다 ViewController를 만들어 뷰의 동작에 관련된 로직 및 컨트롤러 로직을 여기에 구현해야 한다.

단, ViewController는 설정 변경(Configuration Change)으로 인한 라이프사이클 변화에서 살아 남도록 구현해야 한다(ex: 앱이 백그라운드로 넘어갈 때).

### 여전히 존재하는 문제점

**사용자 이벤트와 외부 이벤트 등의 효과적인 처리가 여전히 어려움**

**context의 문제점**

ViewController의 상당수 동작을 위해 context가 필요하다.

Fragment에 연결된 ViewController라면 설정 변경에서 살아남게 만든다는 것이 말처럼 쉽지 않다.

또한, 테스트도 어려워지는 문제점이 있다. 여전히 대부분의 테스트 케이스에 context가 필요하므로 테스트 작성도 까다롭고 테스트 실행 속도도 느리다.

#### 해법: Non - MVC → 뷰와 컨트롤러를 완전히 분리하자

컨트롤러는 context를 모르고도 대부분의 동작을 수행할 수 있어야 한다. MVC의 컨트롤러만으로는 모바일 환경의 이벤트를 처리하는데 부족하다.

### Non - MVC의 설계 전략

#### **Non-MVC에서 Activity는 무엇인가?**

⇒ Activity는 아주 제한적인 컨트롤러의 역할만 해야한다. 액티비티를 뷰로 생각하고 구현하는 것이 무조건 나쁘지는 않지만, 다만 화면의 복잡도가 올라간다면 액티비티가 뷰의 역할을 가지고 있는 것은 바람직하지 않다.

#### MVP의 (궁극적) 접근법

Activity에서 뷰와 컨트롤러의 역할을 최대한 빼앗아 뷰와 프리젠터(Presenter)로 넘긴다.

Activity는 객체 생성 및 순수 흐름 관리 위주로 역할을 담당해야 한다.

#### MVVM / MVI 등의 접근법

단방향 데이터 흐름(Uni-directional Data Flow) : 기본적으로 뷰와 모델의 결합도를 극도로 끊어내, 뷰 모델 혹은 인텐트 구조에서 뷰가 어떤 일을 하고 있는지, 어떤 뷰가 붙어있는지 조차 모르게 해야 한다.

⇒ 뷰 방향의 데이터 흐름을 이벤트를 수신하는 형태로 구현해야 한다.

마찬가지로 Activity는 최대한 일부 context 만을 의존하는 기능만 담당해야 한다.

뷰 로직은 최대한 데이터 바인딩으로 구현해야 한다.
