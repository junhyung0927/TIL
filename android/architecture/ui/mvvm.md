# MVVM

## M-V-ViewModel

![](<../../../.gitbook/assets/Untitled (12) (1).png>)

ViewModel은 프리젠터와 매우 유사한, 뷰모델은 뷰를 제어하지 않는다. 또한 뷰는 뷰모델을 호출하되, 결과는 Callback / Observable 형태로 받는다.



### MVVM의 주요 특징

뷰모델은 그 자체로 독립적인(self-contained) 시스템

* 결과를 이벤트로 보낼 뿐 수신인의 존재는 모름

데이터바인딩을 사용해서 이벤트를 뷰로 바로 적용할 수 있는 매커니즘을 제공



#### MVVM에서 데이터 바인딩은 왜 필요할까?

데이터 바인딩이 없다면 순환 이벤트 흐름을 피하지 못한다.

```kotlin
override fun onViewCreated(...) {
    ...
    viewModel.rememberMe.observe(viewLifeCycleOwner) {
        binding.rememberMeCheckBoxisChecked = it
    }
    
    viewModel.rememberMeCheckBox.setOnCheckedChangeListener { _, isChecked ->
        viewModel.rememberMeChanged(isChecked)
    }
}
```

* 뷰 이벤트 발생 → 뷰모델 처리 후, 이벤트로 알림 → 뷰가 다시 이를 받음

위의 코드와 같이 클릭을 했을 때 뷰의 리스너를 통해서 viewModel에 이벤트를 알린다. 뷰모델이 관련된 작업을 처리한 후 LiveData를 업데이트하여, 이를 관찰하고 있는 객체는 감지하고 뷰의 상태를 변화시킨다.

하지만 데이터바인딩을 사용하면 이런 로직을 xml 단에서 처리하기 때문에 단순 및 명료해진다.



### MVVM의 단점

#### 학습 곡선

뷰에서 발생하는 이벤트는 기본적으로 반응형(Reactive)로 받아야 하므로, RxJava 또는 Coroutines 라이브러리에 대한 학습이 꼭 필요하다.

#### Fat ViewModel이 될 위험성

비즈니스 로직이 많아질수록 필연적으로 ViewModel의 역할이 점점 커질 것이다. 그러므로 큰 크기의 모델을 피하기가 어렵다.

#### Fat ViewModel의 해결책

뷰를 단위별, 로직별로 명확히 그룹핑 할 수 있는 경우나 도메인 지식 관점에서 봤을 때 “어떤 서버에 접근해야 하는가”에 대한 관점(ex: 데이터 로딩) 같은 경우, 뷰를 최대한 분리한다. 그리고 각 뷰마다 뷰모델도 함께 분리한다.

전체 페이지의 상태(ex: 어떤 뷰의 로딩이 발생해도 전체 페이지의 로딩이 발생)와 같이 뷰모델 간 상태 공유가 필요한 경우에는 전역적인 뷰모델(특정 화면 Activity or Fragment)을 만들어 관리할 수 있다.

뷰모델의 비즈니스 로직 중 도메인 로직에 해당하는 부분은 분리하여 도메인 계층으로 이동시킨다.

#### 순환 이벤트 흐름을 완전히 막기 어려움

리스트 내 처리와 같은 것들은 데이터 바인딩을 사용할 수 없기 때문에 결국 순환 이벤트 흐름을 완전히 막기엔 어려움이 있다.

### 왜 구글은 ViewModel만을 AAC에서 지원하는가?

기존 Activity / Fragment의 형태를 깨뜨리지 않으면서 재사용성 / 생산성 높은 아키텍처를 구현 가능하기 때문이다. 뷰모델의 가장 중요한 역할은 UI 상태 데이터를 가지고 있다는 것이다. 뷰와 뷰모델은 각각의 생명주기를 가지고 있기 때문에 구성 변경이 일어나더라도 뷰모델의 데이터는 보존되는 강점을 가진다. 즉, **뷰모델은 UI 상태 데이터를 뷰의 생명주기와 관련 없이 재사용 가능하게 관리하는 목적으로만 사용하도록 제안한 것**이다.

#### AAC ViewModel 내에서 제공하는 것

“_**생명주기 내에서 설정 변경과 프로세스 종료가 일어나도 ViewModel의 내용이 보존되는 구조를 제공한다”**_

일반 변수(Flow, LiveData, Compose State)가 보존될 수 있도록 하는 API를 제공한다(SavedStateHandle). 구성변경이 일어나 액티비티의 생명주기가 onDestory 되도 뷰모델의 상태는 onDestroy가 되지 않아 계속해서 데이터가 살아있다.

Coroutines이 ViewModel의 생명주기 내에서 동작될 수 있도록 하는 환경을 제공한다.



### ViewModel Antipatterns

#### 상태가 유실 될 수 있는 공급자를 통해 이벤트를 전달한다

Channel, Flowable 등의 API는 데이터 전달을 완전히 보장하지 않는다.

시간의 흐름에 따라 위치 데이터를 전달되는 경우 어느정도의 데이터가 유실되도 상관없기에 Channel을 사용하여 전달해도 무관하다.

#### UI 코드에서 액션까지 구현한다

UI는 현재 상태가 무엇이고, 어떻게 반영할지만 결정한다. 비즈니스 로직, 네비게이션 등은 VM의 영역이다.

#### 1회성 이벤트를 즉시 처리하지 않는다

Channel.send(), MutableLiveData.postValue() 등의 API는 낮은 우선순위로 실행될 수 있다.

#### UI 상태 처리에 Compose의 State 대신 StateFlow/SharedFlow를 이용한다

불필요한 오버헤드가 발생한다.



### ViewModel 생성자에서 초기화 이상의 일을 하는 것은 anti pattern!

사실 ViewModel 뿐만 아니라 어떤 종류의 클래스라도 동일하다. 다만 이러한 실수가 ViewModel에서 빈번하게 발생하기에 설명한다.

* SRP(단일 책임 원칙) 위반
  * 호출자(액터)는 기본적으로 뷰다. 뷰가 원하는 것은 생성된 후 관련된 일만 받고 싶을텐데, 서버와 관련된 로딩과 같은 일들을 함께 두 가지 일을 하기 때문에 유지보수에 문제 발생함
* 테스크 구현의 어려움
  * 초기 로딩의 테스크 같은 경우에 나중에 분리될 경우에 문제 발생
* 상속시 자식에게 과도한 정보의 습득을 요구(LSP: 리스코프 치환 원칙 위반)
*   사용자에게 필요없는 초기화를 수행하지 않게 만들 선택권을 박탈

    * 어떤 ViewModel이 초기 로딩 및 특정 변수의 초기화가 필요 없는 경우에 문제 발생



**생성자에서 하면 좋지 않을 일**

* 다른 객체의 생성
* 정적 메서드 호출(유틸리티)
* 필드에 단순 대입 이상의 초기화 로직 구현
* if/when을 이용한 분기 로직

그렇다면 init() 함수와 같은 것들을 만들어야 하나? 사실 init()를 만드는 것이 더욱 좋지 않은 안티 패턴이 될 수 있다. 리스트의 데이터를 불러와 대입하는 로직이 init()에 들어있는 경우, 사용자의 입장에서 해당 클래스 및 함수를 사용하려면 init() 한번 더 호출해야 한다. 즉, 복잡성이 수면 위로 더 올라간다. 또한 클래스의 사용법을 필요 이상 노출 및 잘못 사용될 경우도 있다. 예를 들어 init 함수를 두 번 호출하거나 부르지 않을 경우 에러가 발생할 것이다.

이러한 문제를 해결하기 위해 게으른(lazy) 초기화를 구현하면 된다.
