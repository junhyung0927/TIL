# Room을 사용하여 복잡한 데이터 참조

*   객체 관계 매핑(ORM, Object-Relational Mapping)

    * 객체와 테이블을 자동으로 매핑해주는 기술
    * 객체지향언어에서의 클래스를 관계형 데이터베이스의 테이블을 사용하므로 불일치가 존재
    * ORM을 통해 객체 간 관계를 바탕으로 SQL을 자동으로 생성하여 불일치를 해결

    **장점**

    * 객체 지향적인 코드로 인해 직관적이다
    * 비즈니스 로직에 집중할 수 있도록 지원
    * DBMS에 대한 종속성이 줄어듦
    * 편리성

    **단점**

    * DBMS 고유의 기능을 사용하기 어려움
    * 프로젝트가 커질수록 난이도가 증가함
    * 잘못 구현된 경우 심각한 속도 저하와 일관성을 무너뜨리는 현상이 발생

### Room에서 객체 참조를 허용하지 않는 이유

🗨️ Room은 엔터티 클래스 간 객체 참조를 허용하지 않는다. 대신 앱에 필요한 데이터를 명시적으로 요청해야 한다.

데이터베이스에서 각 객체 모델로 관계를 매핑하는 것은 일반적인 관행이며, 이러한 매핑은 서버 측에서도 잘 작동한다. 또한 필드가 액세스될 때 프로그램이 필드를 로드하는 경우에도 서버에서 잘 작동한다.

그러나 클라이언트 입장에서는 해당 유형의 lazy 로드가 일반적으로 UI 스레드에서 작동하여 실행이 어려운 점을 가지고 있기 때문에 UI 스레드에서 디스크에 관한 정보를 쿼리하게 되면 상당한 성능 이슈 문제를 발생시킨다.

일반적으로 UI 스레드는 액티비티의 업데이트된 레이아웃을 계산하고 그리는데 약 16ms를 소요하므로 쿼리가 5ms 밖에 걸리지 않는 경우에도 앱에서 프레임을 그리는데 시간이 부족할 가능성이 크며, 이에 따라 치명적인 시각적 결함이 발생할 수 있다.

병렬로 실행 중인 별도의 트랜잭션이 있거나 기기가 집약적인 다른 디스크 작업을 실행 중이면 쿼리가 완료되는데 훨씬 많은 시간이 걸릴 수 있다. 그러나 lazy 로드를 사용하지 않으면 앱이 필요한 것보다 더 많은 데이터를 가져오며, 이에 따라 메모리 소비 문제가 발생한다.

객체 관계형 매핑은 일반적으로 개발자가 앱 사용 사례에 가장 적합한 결정을 내릴 수 있게 권한을 맡긴다. 개발자는 일반적으로 앱과 UI 간 모델을 공유하려고 한다. 하지만 이러한 방법은 확장성이 좋지 않다. 시간이 지남에 따라 UI가 변경되므로 공유된 모델이 개발자가 예측 및 디버깅하기 어려운 문제를 발생하기 때문이다.

예를 들어, 각 도서관에 Author 객체가 있는 Book 객체 목록을 로드하는 UI를 생각해보자. 처음에는 lazy 로드를 사용해서 Book 인스턴스가 author를 검색하도록 하는 쿼리를 디자인할 수 있다. author 필드의 첫 번째 검색은 데이터베이스를 쿼리한다. 그 후에 앱 UI에 author 이름을 표시해야 되는 이슈가 생긴다. 다음 코드 스니펫에서와 같이 해당 이름에 매우 쉽게 액세스 할 수 있다는 것을 볼 수 있다.

```kotlin
authorNameTextView.text = book.author.name
```

이러한 변경사항으로 인해 메인 스레드에서 Author 테이블이 쿼리된다.

author 정보를 미리 쿼리하면 데이터가 더 이상 필요 없는 경우에 데이터가 로드되는 방식을 변경하기가 어려워진다.

예를 들어, 앱의 UI가 더 이상 Author 정보를 표시하지 않아도 되는 경우에도 앱은 더 이상 표시하지 않는 데이터를 로드하여 소중한 메모리 공간을 낭비하게 된다. 앱의 효율성은 Author 클래스가 Book과 같은 다른 테이블을 참조하면 훨씬 더 저하되게 된다.

Room을 사용해서 여러 엔터티를 동시에 참조하려면, 각 엔터티가 포함된 POJO를 생성한 후 테이블을 조인하는 쿼리를 작성해라. Room의 강력한 쿼리 유효성 검사 기능과 결합되어 제대로 구조화된 모델을 사용하면 앱이 데이터를 로드할 때 더 적은 리소스를 소비하므로 앱 성능 및 사용자 환경을 향상시킬 수 있다.
